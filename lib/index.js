// Generated by CoffeeScript 1.10.0
var SEPARATOR, async, defaultTokenizer, exec, franc, francOptions, helpers, indexPath, indexer, natural, path, searchIndex, siOptions, stemmers,
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

if (Math.log10 == null) {
  Math.log10 = function(val) {
    return Math.log(val) / Math.LN10;
  };
}

searchIndex = require('search-index');

franc = require('franc');

async = require('async');

path = require('path');

exec = require('child_process').exec;

natural = require('natural');

SEPARATOR = ' ';

indexPath = process.env.INDEXES_PATH || '../search-indexes';

indexPath = path.resolve(__dirname, indexPath);

stemmers = {
  en: require('natural/lib/natural/stemmers/porter_stemmer'),
  fr: require('natural/lib/natural/stemmers/porter_stemmer_fr')
};

defaultTokenizer = new natural.WordTokenizer();

francOptions = {
  minLength: 3,
  whitelist: ['eng', 'fra']
};

siOptions = function() {
  return {
    indexPath: indexPath,
    fieldsToStore: [],
    stopwords: [],
    separator: SEPARATOR
  };
};

helpers = {

  /**
   * Stem the given text by guessing its lang using `franc`
   *
   * @param {string} text value to stem
   * @param {boolean} includeOriginal include the original text in output,
   *                  allow to get matches even if content stemming was not
   *                  done in the same language than query.
   *
   * @return {string} the stemmed text
   */
  stem: function(text, includeOriginal) {
    var lang, out;
    if (includeOriginal == null) {
      includeOriginal = true;
    }
    lang = "en";
    includeOriginal = false;
    if (lang in stemmers) {
      out = stemmers[lang].tokenizeAndStem(text);
    } else {
      out = defaultTokenizer.tokenize(text);
    }
    if (includeOriginal) {
      out.push(text);
    }
    return out.join(SEPARATOR);
  },

  /**
   * Prepare a value for indexing
   * support all type of value (scalar, array, object, undefined)
   * the final value should be a string for non-faceted fields and
   * an array for faceted fields.
   *
   * | value            |  normal      |  stemmed      |   faceted  |
   * | ---------------- | ------------ | ------------- | ---------- |
   * | {a: "test"}      | "a test"     | stem "a test" | NA         |
   * | ['a', 'b']       | "a b"        | stem "a b"    | ['a', 'b'] |
   * | 'Hello'          | "Hello"      | stem "Hello"  | ['hello']  |
   * | null / undefined | undefined    | undefined     | undefined  |
   *
   * @param {mixed} value value to transform
   * @param {boolean} stemmed should we stem the value
   * @param {boolean} facet is this fact
   *
   * @return {string|array} the value prepared. Will be an array if
   *         the field is to be facet, string otherwise
   */
  prepareField: function(value, stemmed, facet, includeObjectKeys) {
    var joined, k, v;
    if (!value) {
      value = void 0;
    } else if (typeof value === 'string') {
      if (stemmed) {
        value = helpers.stem(value);
      }
      if (facet) {
        value = [value.toLowerCase()];
      }
    } else if (Array.isArray(value)) {
      value = value.map(function(part) {
        return helpers.prepareField(part, stemmed);
      });
      if (!facet) {
        value = value.join(SEPARATOR);
      }
    } else if (typeof value === 'object') {
      joined = [];
      for (k in value) {
        v = value[k];
        if (includeObjectKeys) {
          joined.push(k);
        }
        joined.push(helpers.prepareField(v, stemmed));
      }
      value = joined.join(SEPARATOR);
    }
    return value;
  },

  /**
   * Prepare a document for indexing
   * Copy properties from one to a new object, as Cradle response are not
   * simple javascript object and this breaks search-index
   * Pass each field into prepareField
   *
   * @param {object} the document to transform
   * @param {options} the makeBatchOptions return value
   *
   * @return {object} the document prepared.
   */
  makeIndexableDoc: function(doc, options) {
    var field, i, indexable, isFacet, isStem, len, ref, value;
    indexable = {
      id: doc._id
    };
    for (field in doc) {
      if (!hasProp.call(doc, field)) continue;
      value = doc[field];
      isStem = indexOf.call(options.stemmedFields, field) >= 0;
      isFacet = indexOf.call(options.facetFields, field) >= 0;
      indexable[field] = helpers.prepareField(value, isStem, isFacet);
    }
    ref = options.facetFields;
    for (i = 0, len = ref.length; i < len; i++) {
      field = ref[i];
      if (!indexable[field]) {
        indexable[field] = void 0;
      }
    }
    return indexable;
  },

  /**
   * Transform the configuration passed to addBatch into search-index format
   * @TODO memoize this
   *
   * @param {object} fieldOptions the options to transform
   *
   * @return {object} options prepared.
   */
  makeBatchOptions: function(fieldOptions) {
    var batchOptions, field, fieldOption;
    batchOptions = {
      fieldsToStore: [],
      fieldOptions: [],
      stemmedFields: [],
      includeObjectKeys: [],
      facetFields: [],
      defaultFieldOptions: {
        searchable: false,
        fieldedSearch: false
      }
    };
    for (field in fieldOptions) {
      fieldOption = fieldOptions[field];
      fieldOption.fieldName = field;
      if (fieldOption.searchable == null) {
        fieldOption.searchable = true;
      }
      batchOptions.fieldOptions.push(fieldOption);
      if (fieldOption.stemming) {
        batchOptions.stemmedFields.push(field);
      }
      if (fieldOption.filter) {
        batchOptions.facetFields.push(field);
      }
      if (fieldOption.includeObjectKeys) {
        batchOptions.includeObjectKeys.push(field);
      }
    }
    batchOptions.fieldOptions.push({
      fieldName: '*',
      searchable: true,
      fieldedSearch: true
    });
    return batchOptions;
  },
  mergeNGramsLengths: function(oldvalue, newvalue) {
    var gte, lte, ngte, nlte, ogte, olte;
    if (!newvalue) {
      return oldvalue;
    }
    if (!oldvalue) {
      return newvalue;
    }
    ogte = oldvalue.gte || oldvalue;
    olte = oldvalue.lte || oldvalue;
    ngte = newvalue.gte || newvalue;
    nlte = newvalue.lte || newvalue;
    gte = Math.min(ogte, ngte);
    lte = Math.max(olte, nlte);
    if (gte === ogte && lte === olte) {
      return oldvalue;
    } else {
      return {
        gte: gte,
        lte: lte
      };
    }
  }
};

module.exports = indexer = {
  si: null,
  init: function(callback) {
    var ref, ref1, ref2;
    if ((ref = indexer.si) != null ? (ref1 = ref.options) != null ? (ref2 = ref1.indexes) != null ? ref2.isOpen() : void 0 : void 0 : void 0) {
      return callback(null);
    }
    return searchIndex(siOptions(), function(err, si) {
      indexer.si = si;
      return callback(err, si);
    });
  },

  /**
   * Prepare a document for indexing
   * Copy properties from one to a new object, as Cradle response are not
   * simple javascript object and this breaks search-index
   * Pass each field into prepareField
   *
   * @param {object} the document to transform
   * @param {options} a map of fieldName to the options for indexing
   *
   * @return {object} the document prepared.
   */
  addBatch: function(docs, fieldOptions, callback) {
    var batch, doc, i, indexable, len, options;
    if (docs.length === 0) {
      return callback(null);
    }
    options = helpers.makeBatchOptions(fieldOptions);
    batch = [];
    for (i = 0, len = docs.length; i < len; i++) {
      doc = docs[i];
      indexable = helpers.makeIndexableDoc(doc, options);
      if (indexable) {
        batch.push(indexable);
      } else {
        console.log("ignoring doc without indexable field " + doc._id);
      }
    }
    if (batch.length) {
      return indexer.si.add(batch, options, callback);
    } else {
      return setImmediate(callback);
    }
  },

  /**
   * Simple store api to put data in the index, used by the DS to ensure
   * sync is correct.
   */
  store: {
    set: function(key, value, callback) {
      return indexer.si.options.indexes.put('KV￮' + key + '￮', value, callback);
    },
    get: function(key, callback) {
      return indexer.si.options.indexes.get('KV￮' + key + '￮', callback);
    }
  },

  /**
   * Remove a document from the index
   *
   * @params {string} docID
   *
   * @return (callback) when the operation is complete
   */
  forget: function(docID, callback) {
    return indexer.si.del(docID, callback);
  },

  /**
   * Perform a search
   *
   * @params {object} (options) search parameters
   * @params {object} options.search a Map(fieldname -> [search terms])
   * @params {object} options.pageSize
   * @params {object} options.facets a Map(fieldname -> facets options)
   * @params {object} options.filter a Map(fieldname -> facets values)
   * @params {string} lang 2 letter code for the lang this query is in
   *
   * @return (callback) the result of the search
   */
  search: function(options, callback) {
    var err, error, field, params, query, ref, search, stemTerm;
    query = {};
    stemTerm = function(term) {
      return helpers.stem(term, false);
    };
    ref = options.search;
    for (field in ref) {
      search = ref[field];
      query[field] = search.map(stemTerm);
    }
    params = {
      query: query,
      offset: options.offset,
      pageSize: options.pageSize,
      facets: options.facets,
      filter: options.filter
    };
    try {
      return indexer.si.search(params, callback);
    } catch (error) {
      err = error;
      return callback(err);
    }
  },

  /**
   * The normal cleanup method of search-index is too slow
   * instead we just rm -rf the whole index folder
   *
   * @returns (callback) when the db is open again
   */
  cleanup: function(callback) {
    return indexer.si.close(function(err) {
      if (err) {
        return callback(err);
      }
      return exec("rm -rf " + indexPath, function(err) {
        if (err) {
          return callback(err);
        }
        return searchIndex(siOptions(), function(err, si) {
          indexer.si = si;
          return callback(err);
        });
      });
    });
  },

  /**
   * If two applications wants to index a same field using different parameters
   * this function will try to find the best common ground.
   * If there is no change to be made to olddef, we return the actual oldef
   * object, so it is easy to check
   *        mixed = mergeFieldDef oldef, newdef
   *        if mixed === olddef # nothing has changed
   *
   * This function should be convergent
   *        merge(A, B) -> C
   *        merge(C, A) -> C
   *        merge(C, B) -> C
   *
   * @params {object} olddef the current definition for the field
   * @params {object} newdef the new definition for the field
   * @returns {object} olddef if there is no need to change it, a mix of both
                      otherwise
   */
  mergeFieldDef: function(olddef, newdef) {
    var changed, k, merged, nGramLength, trueWins, v;
    if (!olddef) {
      return newdef;
    }
    changed = false;
    merged = {};
    for (k in olddef) {
      v = olddef[k];
      merged[k] = v;
    }
    trueWins = function(name) {
      if (olddef[name] === false && newdef[name]) {
        changed = true;
        return merged[name] = true;
      }
    };
    trueWins('searchable');
    trueWins('fieldedSearch');
    trueWins('stemming');
    if (olddef.weight < newdef.weight) {
      changed = true;
      merged.weight = Math.max(olddef.weight, newdef.weight);
    }
    nGramLength = helpers.mergeNGramsLengths(olddef.nGramLength, newdef.nGramLength);
    if (nGramLength !== olddef.nGramLength) {
      changed = true;
      merged.nGramLength = nGramLength;
    }
    if (changed) {
      return merged;
    } else {
      return olddef;
    }
  }
};
